#!/bin/bash

# Manifest Documentation Module
# Handles documentation generation, README updates, and release notes

# Load markdown templates
if [ -f "$(dirname "$0")/manifest-markdown-templates.sh" ]; then
    source "$(dirname "$0")/manifest-markdown-templates.sh"
fi

generate_release_notes() {
    local version="$1"
    local timestamp="$2"
    
    # Generate filename using configuration
    local filename_pattern="${MANIFEST_DOCS_FILENAME_PATTERN:-RELEASE_vVERSION.md}"
    local release_filename=$(echo "$filename_pattern" | sed "s/VERSION/$version/g")
    
    echo "üìù Generating $release_filename..."
    
    # Create release notes file with proper variable expansion
    cat > "docs/$release_filename" << EOF
# Release v$version

**Release Date:** $timestamp

## üéØ What's New

This release includes various improvements and bug fixes.

## üîß Changes

- General improvements and bug fixes
- Enhanced CLI functionality
- Improved error handling

## üöÄ Installation

\`\`\`bash
# Install the CLI
curl -fsSL https://raw.githubusercontent.com/fidenceio/manifest.cli/main/install-cli.sh | bash

# Or clone and install manually
git clone https://github.com/fidenceio/manifest.cli.git
cd manifest.cli
./install-cli.sh
\`\`\`

## üìã Usage

\`\`\`bash
# Complete workflow
manifest go

# Version bump
manifest go minor

# Test mode
manifest test
\`\`\`

## üîç Testing

\`\`\`bash
# Test all functionality
manifest test all

# Test specific version increments
manifest test versions
\`\`\`

## üìö Documentation

- [README.md](README.md) - Main documentation
- [CHANGELOG.md](CHANGELOG.md) - Complete change history

## üè∑Ô∏è Tags

- **v$version** - This release

## üîó Links

- **Repository:** https://github.com/fidenceio/manifest.cli
- **Issues:** https://github.com/fidenceio/manifest.cli/issues
- **Releases:** https://github.com/fidenceio/manifest.cli/releases

---

*Generated by Manifest CLI v$version*
EOF
    
    echo "‚úÖ $release_filename created"
}

generate_changelog() {
    local version="$1"
    local timestamp="$2"
    
    # Generate filename using configuration
    local changelog_filename="CHANGELOG_v$version.md"
    
    echo "üìù Generating $changelog_filename..."
    
    # Get recent commits for changelog
    local recent_commits=$(git log --oneline -20)
    
    # Create changelog file with proper variable expansion
    cat > "docs/$changelog_filename" << EOF
# Changelog v$version

**Release Date:** $timestamp

## üÜï New Features

- Enhanced CLI functionality
- Improved error handling
- Better cross-platform compatibility

## üîß Improvements

- Code cleanup and optimization
- Enhanced documentation
- Better user experience

## üêõ Bug Fixes

- Fixed various edge cases
- Improved error messages
- Enhanced stability

## üìã Recent Commits

\`\`\`
$recent_commits
\`\`\`

## üîç Technical Details

- **Release Date:** $timestamp
- **Version:** $version
- **Generated:** $(date -u +%Y-%m-%d\ %H:%M:%S\ UTC)

---

*Generated by Manifest CLI v$version*
EOF
    
    echo "‚úÖ $changelog_filename created"
}

update_readme_version() {
    local version="$1"
    local timestamp="$2"
    
    echo "üìù Updating README.md..."
    
    # Check if README.md exists
    if [ ! -f "README.md" ]; then
        echo "   ‚ö†Ô∏è  README.md not found, skipping update"
        return 0
    fi
    
    # Update the version badge in the header
    if grep -q "badge/version-" README.md; then
        # Use a simpler regex that works on macOS sed
        sed -i.tmp "s/badge\/version-[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*/badge\/version-$version/g" README.md
        echo "   ‚úÖ Version badge updated to $version"
    else
        echo "   ‚ÑπÔ∏è  No version badge found, skipping badge update"
    fi
    
    # Update the version information table at the bottom
    if grep -q "Current Version" README.md; then
        # Update the version in the table using awk for better macOS compatibility
        awk -v version="$version" '
        /^\| \*\*Current Version\*\* \| \`[0-9]+\.[0-9]+\.[0-9]+\` \|$/ {
            print "| **Current Version** | `" version "` |"
            next
        }
        /^\| \*\*Git Tag\*\* \| \`v[0-9]+\.[0-9]+\.[0-9]+\` \|$/ {
            print "| **Git Tag** | `v" version "` |"
            next
        }
        /^\| \*\*CLI Version\*\* \| \`[0-9]+\.[0-9]+\.[0-9]+\` \|$/ {
            print "| **CLI Version** | `" version "` |"
            next
        }
        { print }
        ' README.md > README.md.tmp && mv README.md.tmp README.md
        
        echo "   ‚úÖ Version information table updated to $version"
    else
        echo "   ‚ÑπÔ∏è  No version information table found, skipping table update"
    fi
    
    # Clean up temporary files
    rm -f README.md.tmp
    
    echo "   ‚úÖ README.md version information updated"
}

update_repository_metadata() {
    echo "üè∑Ô∏è  Updating repository metadata..."
    
    # Check if we're in a Git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "   ‚ö†Ô∏è  Not in a Git repository, skipping metadata update"
        return 0
    fi
    
    # Detect repository provider
    local remote_url=$(git remote get-url origin 2>/dev/null)
    local provider=""
    
    if [[ "$remote_url" =~ github\.com ]]; then
        provider="github"
    elif [[ "$remote_url" =~ gitlab\.com ]]; then
        provider="gitlab"
    else
        echo "   ‚ö†Ô∏è  Unknown repository provider, skipping metadata update"
        return 0
    fi
    
    echo "   üîÑ Automatically updating repository metadata..."
    
    case "$provider" in
        "github")
            update_github_metadata
            ;;
        "gitlab")
            update_gitlab_metadata
            ;;
        *)
            echo "   ‚ö†Ô∏è  Unsupported provider: $provider"
            return 1
            ;;
    esac
}

update_github_metadata() {
    echo "   ‚úÖ Detected provider: github"
    
    # Check if GitHub CLI is available
    if ! command -v gh &> /dev/null; then
        echo "   ‚ö†Ô∏è  GitHub CLI (gh) not found, skipping metadata update"
        return 0
    fi
    
    # Check if authenticated
    if ! gh auth status &> /dev/null; then
        echo "   ‚ö†Ô∏è  GitHub CLI not authenticated, skipping metadata update"
        return 0
    fi
    
    # Get repository name
    local repo_name=$(basename -s .git "$(git remote get-url origin)")
    local org_name=$(git remote get-url origin | sed -n 's/.*github\.com[:/]\([^/]*\)\/.*/\1/p')
    
    if [ -z "$org_name" ] || [ -z "$repo_name" ]; then
        echo "   ‚ö†Ô∏è  Could not determine repository details, skipping metadata update"
        return 0
    fi
    
    local full_repo="$org_name/$repo_name"
    
    # Update description
    if gh repo edit "$full_repo" --description "Manifest CLI - A powerful command-line tool for Git operations and version management" 2>/dev/null; then
        echo "   ‚úÖ Description updated"
    else
        echo "   ‚ö†Ô∏è  Description update failed (common due to API limitations)"
    fi
    
    # Update topics
    if gh repo edit "$full_repo" --add-topic "cli,git,versioning,automation,bash,shell" 2>/dev/null; then
        echo "   ‚úÖ Topics updated"
    else
        echo "   ‚ö†Ô∏è  Topics update failed (common due to API limitations)"
    fi
    
    # Update homepage
    if gh repo edit "$full_repo" --homepage "https://github.com/$full_repo#readme" 2>/dev/null; then
        echo "   ‚úÖ Homepage updated"
    else
        echo "   ‚ö†Ô∏è  Homepage update failed"
    fi
    
    echo "   ‚úÖ Repository metadata updated automatically"
}

update_gitlab_metadata() {
    echo "   ‚úÖ Detected provider: gitlab"
    
    # Check if GitLab CLI is available
    if ! command -v glab &> /dev/null; then
        echo "   ‚ö†Ô∏è  GitLab CLI (glab) not found, skipping metadata update"
        return 0
    fi
    
    echo "   üîÑ GitLab metadata updates would be implemented here"
    echo "   ‚úÖ Repository metadata updated automatically"
    return 0
}

# Move previous version's documentation to zArchive folder
move_previous_documentation() {
    echo "üìÅ Moving previous version documentation to zArchive..."
    
    # Get current version from VERSION file
    local current_version=""
    if [ -f "VERSION" ]; then
        current_version=$(cat VERSION)

    fi
    
    if [ -z "$current_version" ]; then
        echo "   ‚ö†Ô∏è  Could not determine current version, skipping move operation"
        return 0
    fi
    
    echo "   üìã Current version: $current_version"
    
    # Find and move previous version's documentation files
    local moved_count=0
    
    # Generate filenames using configuration
    local filename_pattern="${MANIFEST_DOCS_FILENAME_PATTERN:-RELEASE_vVERSION.md}"
    local release_filename=$(echo "$filename_pattern" | sed "s/VERSION/$current_version/g")
    local changelog_filename="CHANGELOG_v$current_version.md"
    
    # Move RELEASE files
    if [ -f "docs/$release_filename" ]; then
        mv "docs/$release_filename" "docs/zArchive/"
        echo "   üìÑ Moved $release_filename to zArchive/"
        moved_count=$((moved_count + 1))
    fi
    
    # Move CHANGELOG files
    if [ -f "docs/$changelog_filename" ]; then
        mv "docs/$changelog_filename" "docs/zArchive/"
        echo "   üìÑ Moved $changelog_filename to zArchive/"
        moved_count=$((moved_count + 1))
    fi
    
    # Move any other version-specific documentation files
    for file in docs/*_v$current_version.*; do
        if [ -f "$file" ] && [ "$file" != "docs/*_v$current_version.*" ]; then
            mv "$file" "docs/zArchive/"
            echo "   üìÑ Moved $(basename "$file") to zArchive/"
            moved_count=$((moved_count + 1))
        fi
    done
    
    if [ $moved_count -eq 0 ]; then
        echo "   ‚ÑπÔ∏è  No previous version documentation found to move"
    else
        echo "   ‚úÖ Moved $moved_count documentation file(s) to zArchive/"
    fi
    
    # Clean up zArchive directory (keep only last 10 versions)
    cleanup_zArchive
}

# Clean up zArchive directory to keep only recent versions
cleanup_zArchive() {
    echo "üßπ Cleaning up zArchive directory..."
    
    # Create zArchive directory if it doesn't exist
    mkdir -p docs/zArchive
    
    # Get list of all version files in zArchive
    local version_files=()
    for file in docs/zArchive/*_v*.*; do
        if [ -f "$file" ]; then
            version_files+=("$file")
        fi
    done
    
    # Get historical limit from configuration
    local historical_limit="${MANIFEST_DOCS_HISTORICAL_LIMIT:-20}"
    
    # If we have more than the limit, remove the oldest ones
    if [ ${#version_files[@]} -gt $historical_limit ]; then
        echo "   üìä Found ${#version_files[@]} files, keeping only the $historical_limit most recent..."
        
        # Sort files by modification time (oldest first) and remove oldest
        local files_to_remove=$(ls -t docs/zArchive/*_v*.* 2>/dev/null | tail -n +$((historical_limit + 1)))
        
        for file in $files_to_remove; do
            if [ -f "$file" ]; then
                rm "$file"
                echo "   üóëÔ∏è  Removed old file: $(basename "$file")"
            fi
        done
        
        echo "   ‚úÖ Cleanup completed, kept $historical_limit most recent files"
    else
        echo "   ‚ÑπÔ∏è  zArchive directory is clean (${#version_files[@]} files)"
    fi
}

# Manual function to move existing historical documentation to zArchive
move_existing_historical_docs() {
    echo "üìÅ Moving existing historical documentation to zArchive..."
    
    # Create zArchive directory if it doesn't exist
    mkdir -p docs/zArchive
    
    local moved_count=0
    
    # Move all existing RELEASE and CHANGELOG files
    for file in docs/RELEASE_v*.* docs/CHANGELOG_v*.*; do
        if [ -f "$file" ]; then
            mv "$file" "docs/zArchive/"
            echo "   üìÑ Moved $(basename "$file") to zArchive/"
            moved_count=$((moved_count + 1))
        fi
    done
    
    if [ $moved_count -eq 0 ]; then
        echo "   ‚ÑπÔ∏è  No historical documentation found to move"
    else
        echo "   ‚úÖ Moved $moved_count historical file(s) to zArchive/"
        echo "   üí° You can now run 'manifest docs' to generate current documentation"
    fi
}

generate_documentation() {
    local version="$1"
    local timestamp="$2"
    
    echo "üìö Generating documentation and release notes..."
    
    # Create docs directory if it doesn't exist
    mkdir -p docs
    
    # Create zArchive directory if it doesn't exist
    mkdir -p docs/zArchive
    
    # Generate release notes
    generate_release_notes "$version" "$timestamp"
    
    # Generate changelog
    generate_changelog "$version" "$timestamp"
    
    # Update README
    update_readme_version "$version" "$timestamp"
    
    # Validate markdown files
    if [ -f "scripts/markdown-validator.sh" ]; then
        echo "üîç Validating markdown files..."
        if ./scripts/markdown-validator.sh validate >/dev/null 2>&1; then
            echo "   ‚úÖ All markdown files are valid"
        else
            echo "   ‚ö†Ô∏è  Markdown validation issues found, attempting to fix..."
            if ./scripts/markdown-validator.sh fix >/dev/null 2>&1; then
                echo "   ‚úÖ Markdown issues fixed automatically"
            else
                echo "   ‚ùå Some markdown issues could not be fixed automatically"
            fi
        fi
    fi
    
    echo "‚úÖ Documentation generated successfully"
}
